#include<iostream>
using namespace std;
int main()
{
    /*函数也有地址，其地址是存储其机器语言代码的内存的开始地址，可编写将另一个函数的地址作为
    参数的函数。第一个函数将能找到第二个函数，并运行它。这种方法允许在不同的时间传递不同函数
    的地址，意味着可以在不同的时间使用不同的函数*/
    /*1、获取函数地址
      2、声明函数指针
      3、使用函数指针来调用函数*/

      /*1、获取函数地址：
      使用函数名（后面不跟参数）。如果think()是一个函数，那么think就是该函数的地址。要将函数
      作为参数传递，必须传递函数名。注意区分传递的是函数的地址还是函数的返回值*/
      //process(think) process()函数能在内部调用think()函数
      //thought(think()) thought调用首先调用think()函数，然后将其返回值作为参数传递给thought()函数

      /*2、声明函数指针：
      声明指向函数的指针时，必须指定指针指向的函数的类型。声明应指定函数的返回类型以及函数的特征标（参数列表）。
      声明应像函数原型那样指出有关函数的信息
      示例：
      double pam(int n); 函数原型
      double (*pf)(int); 正确的指针声明。(*pf)是函数，pf是函数指针
      pf=pam; 将相应函数的地址赋给指针
      提示：通常要声明指向特定类型的函数的指针，可以首先编写这种函数的原型，然后用(*pf)替换函数名，这样pf就是
      这类函数的指针
      函数指针声明详解：括号的优先级高于*运算符，因此*pf(int)意思是pf()是一个返回指针的函数，参数是int值，而(*pf)(int)意思是
      pf是一个指向函数参数为int的指针*/

      /*3、使用指针来调用函数:
      (*pf)的作用和函数名是一样的，调用函数时应写为：(*pf)(参数)
      但在C++中用指针调用函数时也可以写为pf(参数)，C语言中不能这么做*/

      /*为什么(*pf)和pf是等价的
      1、pf是函数指针，*pf是函数，因此可以使用(*pf)(参数)作为函数调用语句
      2、函数名是指向该函数的指针，指向函数的指针的行为应与函数名相似，因此应将pf()用作函数调用*/

    return 0;
}
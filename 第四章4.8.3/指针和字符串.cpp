#include <iostream>
#include<cstring>
#include<string>
#pragma warning(disable:4996)
using namespace std;
int main()
{
	char flower[10] = "rose";
	cout << flower << "s are flowers";
	/*flower不止是数组名，也是该数组第一个char型元素的地址，意味着可以将指向char的指针变量作为cout的参数，该指针指向字符串的开头*/
	/*cout语句中后半部分用引号括起的一组字符串，在前面我们一直这样使用以直接使cout打印出我们想要打印的东西，现在解释一下原理：
	引号起了三个作用：在常量区申请空间，并将字符串存入其中；在字符串末尾加上空字符'/0'；返回这段内存的地址，这段地址在执行程序时会将地址返回给cout对象*/
	/*注意：在cout和多数的C++表达式中，char数组名、char指针、用引号括起的字符串常量都被解释为字符串第一个字符的地址*/

	/*下面的程序将演示如何使用不同形式的字符串，其使用了字符串库中的函数
	回顾：函数strlen()返回字符串的长度、函数strcpy()将字符串从一个位置复制到另一个位置*/
	char animal[20] = "bear";/*创建char数组animal,并将其初始化为字符串“bear”*/
	const char* bird = "wren";/*创建指向char的指针变量bird,并将其初始化为指向字符串，注意："wren"实际表示的是字符串的地址，因此这条语句将"wren"
							  的地址赋给了bird指针（一般来说，编译器在内存中留出一些空间），字符串字面值是常量，所以要使用const,意味着可以
							  用bird来访问字符串，而不能修改，第七章介绍const指针*/
							  /*字符串直接量：cout<<"string"<<endl;这种直接输出字符串，不使用变量名来访问内存地址的变量被称为字符串直接量*/
	char animal1[] = "bird";
	animal1[1] = 'a';

	char* ps;/*创建指向char的指针变量ps，此时并没有完全初始化指针ps，因此指针ps不能指向任何字符串*/

	cout << animal << "and" << bird << endl;/*此时animal时字符串"bears"的地址*/
	cout << "输入一种动物：";
	cin >> animal;/*只要输入的长度符合数组animal的长度就是可以的，但使用bird来进行输入并不合适：1、有些编译器将字符串字面值视为只读常量，如果试图修改
				  则会报错。2、有些编译器只使用字符串字面值的一个副本来表示程序中所有的该字面值（C++不能保证字符串字面值被唯一的存储，如果在程序中多次
				  使用字符串字面值，则编译器可能存储该字符串的多个副本或一个副本，如果是一个副本，则bird仅指向了该字符串唯一一个副本，将其他值读入字符串
				  可能会被认为是独立的，位于其他地方的字符串）*/
				  /*在将字符串读入程序时，应使用已分配的内存地址，该地址可以是数组名或者是使用new初始化过的指针*/
				  /*假设在此时输入时输入了fox*/
	ps = animal;/*将animal所在的地址赋给指针ps，到此为止，指针ps完成了初始化，对指针指向的类型和存储的地址都做了规定*/
	cout << ps << "!" << endl;
	cout << "使用函数strcpy()之前" << endl;
	cout << animal << " at " << (int*)animal << endl;
	cout << ps << " at " << (int*)ps << endl;/*因为指针ps的类型是char，因此在打印ps时，cout将显
											 示字符串，要现实字符串的地址必须用强制类型转换*/
											 /*如果为cout提供一个指针，则cout将打印地址。如果指针的类型是char*，则cout将显示指向的字符串
											 如果要显示字符串的地址，必须将指针强制转换为另一种指针类型比如int* */

	ps = new char[strlen(animal) + 1];/*由于fox不能填满animal数组，所以先用函数strlen()确定
									  数组animal的长度，+1来获得包含空字符时该字符串的长度，
									  随后程序使用new来分配刚好存储该字符串的空间*/
									  /*cout << "在没有使用库函数strcpy之前，为animal分配合适的内存之后，ps的地址为" << ps << endl; 这串代码出错了*/
	strcpy(ps, animal);/*使用new为数组animal合适地分配了新空间后，不能直接将animal赋给ps，因为
					   这样只能修改存储在ps中的地址，从而失去程序访问新分配内存的唯一途径*/
					   /*复习函数strcpy(),第一个参数是目标地址，第二个参数是要复制的字符串的地址。且strlen()函数计算的是不包含空
					   字符的字符串长度*/
					   /*在存储副本时，应确定两件事：分配了空间且有足够的空间，首先用strlen来确定所需要的空间，
					   然后用new来获得可用的空间*/
	cout << "使用函数strcpy()之后" << endl;
	/*下面两个语句就说明了我们通过strcpy复制地址函数和new分配空间运算符获得了字符串fox的两个
	独立的副本*/
	cout << animal << " at " << (int*)ps << endl;
	cout << ps << " at " << (int*)ps << endl;

	char food[20] = "shit";
	strcpy(food, "is good");
	cout << food << endl;

	/*如果strcpy函数中的第二个参数所涉及的字符串的长度大于了第一个参数所涉及的字符串怎么办呢：
	函数将字符串中剩余的部分复制到数组后面的内存字节中，可能会覆盖程序正在使用的其他内存，为避免
	这种问题，应该使用函数strncpy(),该函数接受第三个参数--要复制的最大字符数，注意：如果该函数在到达
	字符串结尾之前，目标内存已经用完了，则它不会自动添加空字符，因此应按下列方式使用该函数*/
	strncpy(food, "shit is good", 15);/*目前，第三个参数所设置的最大字符数大于我们想要复制的字符串长度，则函数
									  将在复制完该字符串之后加上空字符*/
	food[19] = '\0';
	/*注意：在C语言中将字符串赋给数组时最好使用函数strcpy和strncpy*/
	delete[]ps;
	cout << endl;
	cout << endl;
	cout << endl;
	cout << endl;
	cout << "测试部分" << endl;
	const char* cp = "C++";
	cout << "*cp=" << *cp << endl;/*指针cp默认指向字符串"C++中"的C,所以在输出*cp时显示指针指向的字符数组的第一个元素*/
	cout << "cp=" << cp << endl;/*用指针名可以直接访问指针指向的字符串*/
	cout << "地址1为：" << (int*)cp << endl;/*用强制类型转换可以显示指针cp指向的首地址，cp指针默认指向字符数组第一个元素
										所以该语句显示字符数组的第一个元素的地址*/
	cout << "地址2为：" << &cp << endl;/*输出指针变量本身的地址,指针存储的是指向变量的地址，指针变量也是变量，也有
								   自己的地址，用&地址运算符+指针名可显示指针的地址*/

	const char** cd = &cp;
	cout << "验证地址：" << cd;
	/**/
	return 0;
}